#!/usr/bin/env python3
"""
Wing Performance Analysis using Blade Element Momentum Theory (BEMT)

This script analyzes rotor/propeller wing designs and computes their aerodynamic
performance characteristics including thrust (lift), power consumption, and efficiency.

The script can:
1. Read wing designs from a CSV file generated by wings_NACA.py
2. Accept manually specified wing parameters via command-line arguments
3. Compute performance under specified operating conditions

Usage:
    # Analyze all designs in a CSV file
    python analyze_wing_performance.py --csv wing_parameters.csv --rpm 3000 --rho 1.225
    
    # Analyze a single design manually
    python analyze_wing_performance.py --manual --rpm 3000 --chord 0.01 --length 0.05 --nwings 4
    
    # Get help on all parameters
    python analyze_wing_performance.py --help
"""

import argparse
import csv
import math
import sys
from typing import Dict, List, Tuple, Optional


class WingDesign:
    """Represents a wing design with all its parameters"""
    
    def __init__(self, case_index: int = 0, overall_length: float = 0.05, 
                 n_wings: int = 4, twist_values: List[float] = None,
                 chord_values: List[float] = None, naca_codes: List[str] = None,
                 valid: bool = True):
        self.case_index = case_index
        self.overall_length = overall_length  # meters - spanwise length along one wing
        self.n_wings = n_wings  # Number of wings in the circular arrangement
        self.valid = valid  # Whether this is a valid design (True) or invalid (False)
        
        # Default values if not provided - use variable length with defaults
        if twist_values is None:
            twist_values = [0.0] * 6
        if chord_values is None:
            chord_values = [0.01] * 6  # meters
        if naca_codes is None:
            naca_codes = ["2412"] * 6
            
        self.twist_values = twist_values
        self.chord_values = chord_values
        self.naca_codes = naca_codes
    
    @classmethod
    def from_csv_row(cls, row: Dict[str, str], default_case_index: int = 0) -> 'WingDesign':
        """Create a WingDesign from a CSV row dictionary"""
        # Make case_index optional - use default if not present or empty in CSV
        try:
            case_index = int(row['case_index']) if 'case_index' in row and row['case_index'].strip() else default_case_index
        except (ValueError, TypeError, AttributeError):
            case_index = default_case_index
        
        # Read validity status (default to True for backwards compatibility)
        valid = True
        if 'valid' in row and row['valid']:
            # Handle numeric (0/1) or string ('true'/'false', 'yes'/'no') formats
            val_str = str(row['valid']).strip().lower()
            # Map common representations to boolean
            if val_str in ('1', 'true', 'yes'):
                valid = True
            elif val_str in ('0', 'false', 'no'):
                valid = False
            else:
                # For other values, try numeric conversion (default to True on failure)
                try:
                    valid = bool(int(val_str))
                except (ValueError, TypeError):
                    valid = True
        
        overall_length = float(row['overall_length'])
        n_wings = int(row['n_wings'])
        
        # Determine the number of sections from the CSV row
        # Count how many naca_N columns exist
        n_sections = 0
        for key in row.keys():
            if key is not None and key.startswith('naca_'):
                n_sections += 1
        
        # If n_sections is explicitly in the CSV, use it
        if 'n_sections' in row:
            n_sections = int(row['n_sections'])
        
        # Extract twist, chord, and NACA values
        twist_values = []
        chord_values = []
        naca_codes = []
        
        for i in range(n_sections):
            twist_key = f'twist_{i}'
            chord_key = f'chord_{i}'
            naca_key = f'naca_{i}'
            
            if twist_key in row and row[twist_key]:
                twist_values.append(float(row[twist_key]))
            if chord_key in row and row[chord_key]:
                chord_values.append(float(row[chord_key]))
            if naca_key in row and row[naca_key]:
                naca_codes.append(row[naca_key])
        
        return cls(case_index, overall_length, n_wings, twist_values, chord_values, naca_codes, valid)
    
    def __repr__(self):
        return (f"WingDesign(case={self.case_index}, length={self.overall_length:.4f}m, "
                f"n_wings={self.n_wings}, avg_chord={sum(self.chord_values)/len(self.chord_values):.4f}m)")


class OperatingConditions:
    """Operating conditions for the wing analysis"""
    
    def __init__(self, rpm: float = 3000.0, rho: float = 1.225, 
                 mu: float = 1.81e-5, altitude: float = 0.0):
        self.rpm = rpm  # Rotations per minute
        self.omega = rpm * 2.0 * math.pi / 60.0  # Convert to rad/s
        self.rho = rho  # Air density in kg/m^3
        self.mu = mu  # Dynamic viscosity in Pa·s
        self.altitude = altitude  # Altitude in meters
        
        # Adjust air properties for altitude if needed
        if altitude > 0:
            self._adjust_for_altitude()
    
    def _adjust_for_altitude(self):
        """Adjust air density and viscosity for altitude using standard atmosphere model"""
        # Simple exponential model for troposphere (valid up to ~11km)
        h = self.altitude
        rho_sl = 1.225  # Sea level density
        T_sl = 288.15  # Sea level temperature in K
        L = 0.0065  # Temperature lapse rate K/m
        
        T = T_sl - L * h
        self.rho = rho_sl * (T / T_sl) ** 4.256
        
        # Viscosity increases slightly with altitude due to temperature
        # Sutherland's formula
        T_ref = 288.15
        mu_ref = 1.81e-5
        S = 110.4  # Sutherland constant
        self.mu = mu_ref * (T / T_ref) ** 1.5 * (T_ref + S) / (T + S)
    
    def __repr__(self):
        return (f"OperatingConditions(RPM={self.rpm:.1f}, rho={self.rho:.3f}kg/m³, "
                f"altitude={self.altitude:.1f}m)")


class NACAProfile:
    """NACA 4-digit airfoil profile characteristics"""
    
    def __init__(self, code: str):
        self.code = code.strip()
        if len(self.code) != 4 or not self.code.isdigit():
            raise ValueError(f"NACA code must be 4 digits, got: {code}")
        
        # Parse NACA 4-digit code
        self.m = int(self.code[0]) / 100.0  # Maximum camber
        self.p = int(self.code[1]) / 10.0   # Position of maximum camber
        self.t = int(self.code[2:]) / 100.0  # Maximum thickness
    
    def estimate_cl_alpha(self) -> float:
        """
        Estimate the lift curve slope (dCl/dα) in per radian
        
        Theoretical thin airfoil theory gives 2π per radian (~0.11 per degree)
        For finite thickness and camber, we adjust slightly
        """
        # Base value from thin airfoil theory
        cl_alpha = 2.0 * math.pi
        
        # Small adjustment for thickness (reduces slope slightly)
        cl_alpha *= (1.0 - 0.5 * self.t)
        
        return cl_alpha
    
    def estimate_cl0(self) -> float:
        """
        Estimate the zero-angle-of-attack lift coefficient
        This is primarily determined by camber
        """
        # Simple linear approximation based on camber
        return 2.0 * math.pi * self.m * (self.p if self.p > 0 else 0.5)
    
    def estimate_cd0(self) -> float:
        """
        Estimate the zero-lift drag coefficient
        Primarily determined by thickness
        """
        # Empirical correlation for NACA 4-digit profiles
        # Cd0 increases roughly with thickness squared
        return 0.006 + 0.15 * self.t ** 2
    
    def estimate_cd_induced_factor(self) -> float:
        """
        Estimate the induced drag factor k in: Cd = Cd0 + k*Cl^2
        For an ideal elliptical wing, k = 1/(π*AR)
        We return a base factor that will be adjusted for aspect ratio
        """
        return 1.0


class BEMTAnalyzer:
    """
    Blade Element Momentum Theory analyzer for rotor performance
    
    This implements a simplified BEMT algorithm that:
    1. Divides each blade into radial elements
    2. Computes local aerodynamic forces based on local velocity and blade geometry
    3. Iterates to find consistent flow field (induced velocities)
    4. Integrates forces to get total thrust and power
    """
    
    def __init__(self, wing_design: WingDesign, conditions: OperatingConditions,
                 n_elements: int = 20, convergence_tol: float = 1e-4, max_iter: int = 100):
        self.wing = wing_design
        self.conditions = conditions
        self.n_elements = n_elements
        self.convergence_tol = convergence_tol
        self.max_iter = max_iter
        
        # Data is already in SI units (meters)
        self.R = wing_design.overall_length  # meters - outer radius
        # Assume hub radius is small compared to total radius
        self.R_hub = self.R * 0.1  # 10% of total radius as hub
        
    def analyze(self) -> Dict[str, float]:
        """
        Perform BEMT analysis and return performance metrics
        
        Returns:
            Dictionary with keys:
            - thrust_total: Total thrust/lift in N
            - power_total: Total power in W
            - torque_total: Total torque in N·m
            - efficiency: Propeller efficiency (thrust*V / power)
            - ct: Thrust coefficient
            - cp: Power coefficient
            - figure_of_merit: For hovering rotors
        """
        # Create radial stations
        r_stations = self._create_radial_stations()
        
        # Compute dr for each station (for momentum theory)
        dr_values = []
        for i in range(len(r_stations)):
            if i == 0:
                # First element: use half distance to next station
                dr = (r_stations[i + 1] - r_stations[i]) / 2.0
            elif i == len(r_stations) - 1:
                # Last element: use half distance from previous station
                dr = (r_stations[i] - r_stations[i - 1]) / 2.0
            else:
                # Middle elements: use average of distances to neighbors
                dr = (r_stations[i + 1] - r_stations[i - 1]) / 2.0
            dr_values.append(dr)
        
        # Interpolate wing properties at each station
        elements = []
        for i, r in enumerate(r_stations):
            element = self._create_blade_element(r)
            element['dr'] = dr_values[i]  # Add dr to element data
            elements.append(element)
        
        # Iterate BEMT for each element
        results = []
        for element in elements:
            result = self._solve_element(element)
            results.append(result)
        
        # Integrate to get total forces
        return self._integrate_results(results, r_stations)
    
    def _create_radial_stations(self) -> List[float]:
        """
        Create radial stations from hub to tip for computational analysis.
        
        Note: These computational stations use cosine spacing for better numerical accuracy.
        The input design parameters (chord, twist, NACA) are assumed to be specified at
        equally-spaced stations along the blade, and are interpolated to these computational
        stations during analysis.
        """
        if self.n_elements < 2:
            raise ValueError("Number of elements must be at least 2 for analysis")
        
        # Warn if element count is low for accuracy
        if self.n_elements < 10:
            import warnings
            warnings.warn(
                f"Using only {self.n_elements} elements may reduce accuracy. "
                "Consider using at least 10-15 elements for better results.",
                UserWarning
            )
        
        stations = []
        for i in range(self.n_elements):
            # Use cosine spacing for better resolution near hub and root
            theta = math.pi * i / (self.n_elements - 1)
            r_norm = 0.5 * (1.0 - math.cos(theta))
            r = self.R_hub + r_norm * (self.R - self.R_hub)
            stations.append(r)
        return stations
    
    def _create_blade_element(self, r: float) -> Dict:
        """
        Create a blade element at radius r with interpolated properties
        
        r: radial position in meters
        
        Returns a dictionary with blade properties. The 'dr' field will be set
        by the caller based on the radial station spacing.
        """
        # Normalize r to [0, 1] along the blade span
        r_norm = (r - self.R_hub) / (self.R - self.R_hub) if self.R > self.R_hub else 0.0
        
        # Interpolate chord length (linear interpolation between stations)
        chord = self._interpolate_property(r_norm, self.wing.chord_values)  # already in meters
        
        # Interpolate twist angle
        twist_deg = self._interpolate_property(r_norm, self.wing.twist_values)
        twist_rad = math.radians(twist_deg)
        
        # Get NACA profile at this station (use closest station)
        n_naca_stations = len(self.wing.naca_codes)
        if n_naca_stations > 0:
            station_idx = min(int(r_norm * (n_naca_stations - 0.001)), n_naca_stations - 1)
            naca_code = self.wing.naca_codes[station_idx]
        else:
            naca_code = "2412"  # Default fallback
        naca = NACAProfile(naca_code)
        
        return {
            'r': r,
            'chord': chord,
            'twist': twist_rad,
            'naca': naca,
            'dr': 0.0  # Will be set during integration
        }
    
    def _interpolate_property(self, r_norm: float, values: List[float]) -> float:
        """
        Interpolate a property value at normalized radius r_norm [0, 1]
        given station values
        """
        # Linear interpolation between stations
        n_stations = len(values)
        if n_stations == 0:
            return 0.0
        if n_stations == 1:
            return values[0]
        
        # Find which segment we're in
        segment = r_norm * (n_stations - 1)
        idx_low = int(math.floor(segment))
        idx_high = int(math.ceil(segment))
        
        # Clamp to valid range
        idx_low = max(0, min(idx_low, n_stations - 1))
        idx_high = max(0, min(idx_high, n_stations - 1))
        
        if idx_low == idx_high:
            return values[idx_low]
        
        # Linear interpolation
        alpha = segment - idx_low
        return values[idx_low] * (1.0 - alpha) + values[idx_high] * alpha
    
    def _solve_element(self, element: Dict) -> Dict:
        """
        Solve for forces on a single blade element using BEMT
        
        This iterates to find the induced velocity that satisfies both
        momentum theory and blade element theory
        """
        r = element['r']
        chord = element['chord']
        twist = element['twist']
        naca = element['naca']
        
        # Tangential velocity due to rotation
        V_rot = self.conditions.omega * r
        
        # Initialize induced velocity (axial inflow)
        v_induced = 0.0
        
        # BEMT iteration
        for iteration in range(self.max_iter):
            v_induced_old = v_induced
            
            # Local flow angle (angle between relative wind and rotor plane)
            # For a hovering rotor, V_axial ≈ v_induced
            V_axial = v_induced
            phi = math.atan2(V_axial, V_rot)
            
            # Local angle of attack
            alpha = twist - phi
            
            # Get airfoil coefficients
            cl = naca.estimate_cl0() + naca.estimate_cl_alpha() * alpha
            cd = naca.estimate_cd0() + 0.01 * cl ** 2  # Simple drag polar
            
            # Limit cl to reasonable range (stall modeling)
            cl_max = 1.5
            cl_min = -1.0
            if cl > cl_max:
                cl = cl_max
                cd += 0.1 * (cl - cl_max)  # Increased drag post-stall
            elif cl < cl_min:
                cl = cl_min
                cd += 0.1 * (cl_min - cl)
            
            # Local dynamic pressure
            V_rel = math.sqrt(V_axial**2 + V_rot**2)
            q = 0.5 * self.conditions.rho * V_rel ** 2
            
            # Forces per unit span
            dL = q * chord * cl  # Lift per unit span
            dD = q * chord * cd  # Drag per unit span
            
            # Resolve into thrust (axial) and torque (tangential) components
            dT_element = dL * math.cos(phi) - dD * math.sin(phi)
            dQ_element = (dL * math.sin(phi) + dD * math.cos(phi)) * r
            
            # Update induced velocity using momentum theory
            # Simple fixed-point iteration
            # dT = 2 * rho * A * v_induced * (V_axial + v_induced)
            # For a rotor disk, this is simplified
            
            # Prandtl tip loss factor (reduces induced velocity near tip)
            B = self.wing.n_wings  # Number of blades
            f = (B / 2.0) * (self.R - r) / (r * math.sin(abs(phi)) + 1e-6)
            # Clamp the argument to acos to valid range [-1, 1]
            exp_val = math.exp(-abs(f))
            acos_arg = max(-1.0, min(1.0, exp_val))
            F = (2.0 / math.pi) * math.acos(acos_arg) if abs(f) < 10 else 1.0
            F = max(0.1, F)  # Prevent division by zero
            
            # Momentum theory update
            # For an annular element, the momentum theory gives:
            # T_annulus = 2 * rho * A_annulus * v_i^2
            # where A_annulus = 2 * pi * r * dr and T_annulus = dT * dr
            # Solving for v_i: v_i = sqrt(dT / (4 * pi * rho * r))
            # where dT is thrust per unit span from all blades
            if dT_element > 0 and r > 0:
                # dT_element is per single blade, multiply by n_wings for total
                thrust_total = dT_element * self.wing.n_wings
                denominator = 4.0 * math.pi * self.conditions.rho * r * F
                if denominator > 1e-10:  # Prevent division by very small numbers
                    v_induced_new = math.sqrt(thrust_total / denominator)
                else:
                    v_induced_new = 0.0
            else:
                v_induced_new = 0.0
            
            # Relaxation for stability
            relax = 0.5
            v_induced = relax * v_induced_new + (1.0 - relax) * v_induced_old
            
            # Check convergence
            if abs(v_induced - v_induced_old) < self.convergence_tol:
                break
        
        # Store final results for this element
        return {
            'r': r,
            'dT': dT_element * self.wing.n_wings,  # Total thrust from all blades
            'dQ': dQ_element * self.wing.n_wings,  # Total torque from all blades
            'v_induced': v_induced,
            'alpha': alpha,
            'cl': cl,
            'cd': cd,
            'phi': phi,
            'V_rel': V_rel
        }
    
    def _integrate_results(self, results: List[Dict], r_stations: List[float]) -> Dict[str, float]:
        """
        Integrate element results to get total performance
        """
        if len(results) < 2 or len(r_stations) < 2:
            raise ValueError("Need at least 2 elements for integration")
        
        thrust_total = 0.0
        torque_total = 0.0
        power_total = 0.0
        
        # Trapezoidal integration
        for i in range(len(results) - 1):
            r1, r2 = r_stations[i], r_stations[i + 1]
            dr = r2 - r1
            
            # Average forces over the element
            dT_avg = (results[i]['dT'] + results[i + 1]['dT']) / 2.0
            dQ_avg = (results[i]['dQ'] + results[i + 1]['dQ']) / 2.0
            
            thrust_total += dT_avg * dr
            torque_total += dQ_avg * dr
        
        # Power from torque
        power_total = torque_total * self.conditions.omega
        
        # Compute non-dimensional coefficients
        # Reference area (disk area)
        A_disk = math.pi * self.R ** 2
        
        # Advance ratio (J = V / (n * D)) - for hovering, J ≈ 0
        # Thrust coefficient: CT = T / (rho * n^2 * D^4)
        n = self.conditions.rpm / 60.0  # Revolutions per second
        D = 2.0 * self.R
        
        ct = thrust_total / (self.conditions.rho * n**2 * D**4) if n > 0 else 0.0
        cp = power_total / (self.conditions.rho * n**3 * D**5) if n > 0 else 0.0
        
        # Figure of merit (for hovering)
        # FM = (ideal power) / (actual power) = T^(3/2) / sqrt(2*rho*A) / P
        # Only valid for positive thrust (hovering condition)
        if power_total > 0 and thrust_total > 0:
            P_ideal = (thrust_total ** 1.5) / math.sqrt(2.0 * self.conditions.rho * A_disk)
            figure_of_merit = P_ideal / power_total
        else:
            figure_of_merit = 0.0
        
        # Propeller efficiency (for forward flight)
        # eta = T * V_forward / P
        # For hovering rotors without forward velocity, we compute a normalized
        # hover efficiency metric using a reference velocity (1% of tip speed)
        # This provides a dimensionless comparison metric between designs
        V_tip = self.conditions.omega * self.R
        V_reference = V_tip * 0.01  # Reference velocity = 1% of tip speed
        efficiency = (thrust_total * V_reference) / power_total if power_total > 0 else 0.0
        
        return {
            'thrust_total': thrust_total,
            'power_total': power_total,
            'torque_total': torque_total,
            'ct': ct,
            'cp': cp,
            'efficiency': efficiency,
            'figure_of_merit': figure_of_merit,
            'tip_speed': V_tip,
            'disk_area': A_disk
        }


def load_designs_from_csv(csv_file: str) -> List[WingDesign]:
    """Load wing designs from a CSV file"""
    designs = []
    try:
        with open(csv_file, 'r') as f:
            reader = csv.DictReader(f)
            for idx, row in enumerate(reader):
                # Pass row index as default case_index if not present in CSV
                design = WingDesign.from_csv_row(row, default_case_index=idx)
                designs.append(design)
        print(f"Loaded {len(designs)} wing designs from {csv_file}")
    except FileNotFoundError:
        print(f"Error: CSV file '{csv_file}' not found")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading CSV file: {e}")
        sys.exit(1)
    
    return designs


def create_manual_design(args) -> WingDesign:
    """Create a wing design from command-line arguments"""
    # Use provided values or defaults
    overall_length = args.length
    n_wings = args.nwings
    n_sections = args.nsections
    
    # Create uniform arrays if not specified
    chord_values = [args.chord] * n_sections
    twist_values = [args.twist] * n_sections
    naca_codes = [args.naca] * n_sections
    
    return WingDesign(
        case_index=0,
        overall_length=overall_length,
        n_wings=n_wings,
        twist_values=twist_values,
        chord_values=chord_values,
        naca_codes=naca_codes
    )


def format_results(design: WingDesign, conditions: OperatingConditions, 
                   results: Dict[str, float]) -> str:
    """Format analysis results as a readable string"""
    lines = []
    lines.append("=" * 70)
    lines.append(f"Wing Design Analysis - Case {design.case_index}")
    lines.append("=" * 70)
    lines.append(f"Design: {design}")
    lines.append(f"Conditions: {conditions}")
    lines.append("-" * 70)
    lines.append("Performance Metrics:")
    lines.append(f"  Thrust (Lift):        {results['thrust_total']:8.2f} N")
    lines.append(f"  Power Required:       {results['power_total']:8.2f} W")
    lines.append(f"  Torque:               {results['torque_total']:8.3f} N·m")
    lines.append(f"  Thrust Coefficient:   {results['ct']:8.5f}")
    lines.append(f"  Power Coefficient:    {results['cp']:8.5f}")
    lines.append(f"  Figure of Merit:      {results['figure_of_merit']:8.3f}")
    lines.append(f"  Efficiency:           {results['efficiency']:8.3f}")
    lines.append(f"  Tip Speed:            {results['tip_speed']:8.2f} m/s")
    lines.append(f"  Rotor Disk Area:      {results['disk_area']:8.4f} m²")
    lines.append("=" * 70)
    lines.append("")
    
    return "\n".join(lines)


def write_results_to_csv(output_file: str, designs: List[WingDesign], 
                         conditions: OperatingConditions, 
                         all_results: List[Dict[str, float]]):
    """Write analysis results to a CSV file"""
    try:
        with open(output_file, 'w', newline='') as f:
            fieldnames = [
                'case_index', 'overall_length', 'n_wings',
                'chord_0', 'chord_1', 'chord_2', 'chord_3', 'chord_4', 'chord_5',
                'naca_0', 'naca_1', 'naca_2', 'naca_3', 'naca_4', 'naca_5',
                'twist_0', 'twist_1', 'twist_2', 'twist_3', 'twist_4', 'twist_5',
                'rpm', 'rho', 'altitude',
                'thrust_N', 'power_W', 'torque_Nm',
                'ct', 'cp', 'figure_of_merit', 'efficiency',
                'tip_speed_ms', 'disk_area_m2'
            ]
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            
            for design, results in zip(designs, all_results):
                row = {
                    'case_index': design.case_index,
                    'overall_length': design.overall_length,
                    'n_wings': design.n_wings,
                    'rpm': conditions.rpm,
                    'rho': conditions.rho,
                    'altitude': conditions.altitude,
                    'thrust_N': results['thrust_total'],
                    'power_W': results['power_total'],
                    'torque_Nm': results['torque_total'],
                    'ct': results['ct'],
                    'cp': results['cp'],
                    'figure_of_merit': results['figure_of_merit'],
                    'efficiency': results['efficiency'],
                    'tip_speed_ms': results['tip_speed'],
                    'disk_area_m2': results['disk_area']
                }
                
                # Add chord lengths (ensure we have 6 values, pad with empty string if needed)
                for i in range(6):
                    if i < len(design.chord_values):
                        row[f'chord_{i}'] = design.chord_values[i]
                    else:
                        row[f'chord_{i}'] = ''
                
                # Add NACA codes (ensure we have 6 values, pad with empty string if needed)
                for i in range(6):
                    if i < len(design.naca_codes):
                        row[f'naca_{i}'] = design.naca_codes[i]
                    else:
                        row[f'naca_{i}'] = ''
                
                # Add twist angles (ensure we have 6 values, pad with empty string if needed)
                for i in range(6):
                    if i < len(design.twist_values):
                        row[f'twist_{i}'] = design.twist_values[i]
                    else:
                        row[f'twist_{i}'] = ''
                
                writer.writerow(row)
        
        print(f"\nResults written to {output_file}")
    except Exception as e:
        print(f"Error writing results to CSV: {e}")


def main():
    parser = argparse.ArgumentParser(
        description='Analyze wing performance using Blade Element Momentum Theory',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Analyze all designs from CSV
  python analyze_wing_performance.py --csv wing_parameters.csv --rpm 3000
  
  # Analyze a single manual design
  python analyze_wing_performance.py --manual --rpm 3000 --chord 0.01 --length 0.05 --nwings 4
  
  # Save results to output CSV
  python analyze_wing_performance.py --csv wing_parameters.csv --rpm 3000 --output results.csv
  
  # Adjust for altitude
  python analyze_wing_performance.py --csv wing_parameters.csv --rpm 3000 --altitude 1000
        """
    )
    
    # Input source
    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument('--csv', type=str, help='CSV file with wing parameters')
    input_group.add_argument('--manual', action='store_true', 
                           help='Manually specify wing parameters')
    
    # Operating conditions
    parser.add_argument('--rpm', type=float, required=True,
                       help='Rotation speed in RPM')
    parser.add_argument('--rho', type=float, default=1.225,
                       help='Air density in kg/m³ (default: 1.225 at sea level)')
    parser.add_argument('--mu', type=float, default=1.81e-5,
                       help='Dynamic viscosity in Pa·s (default: 1.81e-5)')
    parser.add_argument('--altitude', type=float, default=0.0,
                       help='Altitude in meters (overrides rho if specified)')
    
    # Manual design parameters
    parser.add_argument('--chord', type=float, default=0.01,
                       help='Chord length in meters (for manual mode, default: 0.01)')
    parser.add_argument('--length', type=float, default=0.05,
                       help='Wing span length in meters (for manual mode, default: 0.05)')
    parser.add_argument('--twist', type=float, default=0.0,
                       help='Twist angle in degrees (for manual mode, default: 0)')
    parser.add_argument('--nwings', type=int, default=4,
                       help='Number of wings (for manual mode, default: 4)')
    parser.add_argument('--naca', type=str, default='2412',
                       help='NACA 4-digit code (for manual mode, default: 2412)')
    parser.add_argument('--nsections', type=int, default=6,
                       help='Number of cross-sections (for manual mode, default: 6)')
    
    # Analysis options
    parser.add_argument('--elements', type=int, default=20,
                       help='Number of blade elements for analysis (default: 20)')
    parser.add_argument('--max-iter', type=int, default=100,
                       help='Maximum BEMT iterations (default: 100)')
    
    # Output options
    parser.add_argument('--output', type=str, help='Output CSV file for results')
    parser.add_argument('--quiet', action='store_true',
                       help='Suppress detailed output')
    
    args = parser.parse_args()
    
    # Create operating conditions
    conditions = OperatingConditions(
        rpm=args.rpm,
        rho=args.rho,
        mu=args.mu,
        altitude=args.altitude
    )
    
    # Load or create designs
    if args.csv:
        designs = load_designs_from_csv(args.csv)
    else:
        designs = [create_manual_design(args)]
    
    if not designs:
        print("No designs to analyze")
        sys.exit(1)
    
    # Count valid and invalid designs
    valid_designs = [d for d in designs if d.valid]
    invalid_designs = [d for d in designs if not d.valid]
    
    if not args.quiet:
        print(f"Loaded {len(designs)} designs ({len(valid_designs)} valid, {len(invalid_designs)} invalid)")
        if invalid_designs:
            print(f"Skipping {len(invalid_designs)} invalid designs: {[d.case_index for d in invalid_designs]}")
    
    # Analyze each valid design
    all_results = []
    analyzed_designs = []
    for design in designs:
        if not design.valid:
            # Skip invalid designs
            if not args.quiet:
                print(f"\nSkipping invalid design {design.case_index}...")
            continue
        
        analyzer = BEMTAnalyzer(
            design, 
            conditions,
            n_elements=args.elements,
            max_iter=args.max_iter
        )
        
        if not args.quiet:
            print(f"\nAnalyzing design {design.case_index}...")
        
        results = analyzer.analyze()
        all_results.append(results)
        analyzed_designs.append(design)
        
        if not args.quiet:
            print(format_results(design, conditions, results))
    
    # Write results to CSV if requested
    if args.output:
        write_results_to_csv(args.output, analyzed_designs, conditions, all_results)
    
    # Summary
    if not args.quiet and len(analyzed_designs) > 1:
        print("\n" + "=" * 70)
        print("SUMMARY")
        print("=" * 70)
        print(f"Analyzed {len(analyzed_designs)} valid designs (skipped {len(invalid_designs)} invalid)")
        avg_thrust = sum(r['thrust_total'] for r in all_results) / len(all_results)
        avg_power = sum(r['power_total'] for r in all_results) / len(all_results)
        print(f"Average Thrust: {avg_thrust:.2f} N")
        print(f"Average Power:  {avg_power:.2f} W")
        
        # Find best design by figure of merit (from analyzed designs)
        best_idx = max(range(len(all_results)), 
                      key=lambda i: all_results[i]['figure_of_merit'])
        print(f"\nBest design by Figure of Merit: Case {analyzed_designs[best_idx].case_index}")
        print(f"  FM = {all_results[best_idx]['figure_of_merit']:.3f}")
        print(f"  Thrust = {all_results[best_idx]['thrust_total']:.2f} N")
        print(f"  Power = {all_results[best_idx]['power_total']:.2f} W")
    
    return 0


if __name__ == '__main__':
    sys.exit(main())
